import textwrap

from nbformat import NotebookNode
from nbformat.v4 import new_markdown_cell, new_code_cell, new_notebook

from ewatercycle_experiment_launcher.generate import PY3_META
from ewatercycle_experiment_launcher.process import process_notebook


def assessment_notebook(setup) -> NotebookNode:
    """Generates a Jupyter notebook"""
    welcome = textwrap.dedent("""
        # **Welcome to the eWaterCycle expirement notebook**
        
        This notebook was generated by the eWaterCycle experiment launcher.
        
        We will use GRDC data for comparison between the model simulation and the observations.
        
        In this example notebook we run a hydrology model using [grpc4bmi](https://github.com/eWaterCycle/grpc4bmi), but you can also choose to run your own model, WFLOW or Walrus.
        """)
    assessment_source = setup['assessment']['source']
    observation_import = 'from ewatercycle.observation.grdc import get_grdc_data'
    if assessment_source == 'usgs':
        observation_import = 'from ewatercycle.observation.usgs import get_usgs_data'
    cells = [
        new_markdown_cell(welcome),
        new_code_cell(textwrap.dedent("""\
            %matplotlib inline  
            import os
            
            import cftime
            import hydrostats.visual as hv
            import matplotlib.pyplot as plt
            import numpy as np
            import numpy.ma as ma
            import pandas as pd
            import xarray as xr
            
            from ewatercycle.parametersetdb import build_from_urls
            {0}
            from grpc4bmi.bmi_client_docker import BmiClientDocker""".format(observation_import))),
        new_markdown_cell('## **Setting the input and output configuration**'),
        new_code_cell(textwrap.dedent("""\
            parameter_set = build_from_urls(
                config_format='{0}', config_url='{1}',
                datafiles_format='{2}', datafiles_url='{3}',
            )""".format(setup['config']['format'], setup['config']['url'],
                        setup['datafiles']['format'], setup['datafiles']['url'],
                        )
        )),
        new_markdown_cell('Save data files'),
        new_code_cell("parameter_set.save_datafiles('./input')"),
        new_markdown_cell(textwrap.dedent("""\
            Overwrite items in config file by using
             ```python
             parameter_set.config['...']['...'] = '...'
             ```""")),
        new_markdown_cell(textwrap.dedent("""\
            The model inside a BMI Docker container expects the datafiles in the /data/input directory,
            the config file must be adjusted to that. 
            
            *Please note that creating the input/output folders should be done only once.*
            """))
    ]

    model_name = setup['model']['name']
    config_fn = 'config.cfg'
    if model_name == 'wflow':
        config_fn = 'wflow_sbm.ini'
        cells += [
            new_markdown_cell('For **wflow** model the config file must be set with: '),
            new_code_cell(textwrap.dedent("""\
                parameter_set.config['model']['configfile'] = '/data/input/{0}'""".format(config_fn))),
        ]
    elif model_name == 'Walrus':
        cells += [
            new_markdown_cell('For **Walrus** model the data file must be set with'),
            new_code_cell(textwrap.dedent("""\
                import os
                parameter_set.config['data'] = '/data/input/' + os.listdir('input')[0]""")),
        ]
    elif model_name == 'PCR-GLOBWB':
        cells += [
            new_markdown_cell('For **PCR-GLOBWB** model the input and output directory must be set with:'),
            new_code_cell(textwrap.dedent("""\
                parameter_set.config['globalOptions']['inputDir'] = '/data/input'
                parameter_set.config['globalOptions']['outputDir'] = '/data/output'""")),
        ]
    cells += [
        new_markdown_cell('Then it must be saved to the config file:'),
        new_code_cell("parameter_set.save_config('{0}')".format(config_fn)),
        new_markdown_cell(textwrap.dedent("""\
            ## **Run docker container that contains model**

            In this example we use {0}, the model is loaded and initialized according to the configuration file we created in the previous section.""").format(model_name)),
        new_code_cell(textwrap.dedent("""\
            # Startup model
            model = BmiClientDocker(image='{0}', image_port=55555,
                                    input_dir="./input",
                                    output_dir="./output")
            model.initialize('{1}')""".format(setup['model']['grpc4bmi_container'], config_fn)
        )),
        new_markdown_cell('Gather information about the way the model handles time as this is needed to evolve the model.'),
        new_code_cell(textwrap.dedent("""\
            tstart = int(model.get_start_time())
            tend = int(model.get_end_time())
            tstep = int(model.get_time_step())
            tunit = model.get_time_units()
            tstep_nmbr = (tend - tstart) / tstep""")),
        new_markdown_cell(textwrap.dedent("""\
            ### Evolve the model and capture variable discharge
            
            Select the variable of our choice and the index of the pixel to record. The pixel index should correspond to the location of the GRDC station that is used to compare the model with.
            """)),
        new_code_cell(textwrap.dedent("""\
            variable = '{0}'
            pixel_index = np.array([{1}])
            variable_overtime = []""".format(setup['assessment']['variable'], setup['assessment']['index'])))
        new_code_cell(textwrap.dedent("""\
            while model.get_current_time() < tend:
            model.update()
            value_at_pixel = model.get_value_at_indices(variable, pixel_index)[0]
            variable_overtime.append((model.get_current_time(), value_at_pixel))""")),
        new_markdown_cell(textwrap.dedent("""\
            ## **Visualizing the output**
            
            ### Plot the variable at the current time as a function of lon/lat
            
            Get the variable values at the current time, coordinates and other useful information for this plot. Since the model just ran until `tend`, this the current time. """)),
        new_code_cell(textwrap.dedent("""\
            vals = model.get_value(variable)
            unit = model.get_var_units(variable)
            shape = model.get_grid_shape(model.get_var_grid(variable))
            lon = model.get_grid_x(0)
            lat = model.get_grid_y(0)
            current_date = cftime.num2date(model.get_current_time(),tunit).date()""")),
        new_markdown_cell('Reshape the one dimensional list of values to a two dimensional array for plotting and make the plot'),
        new_code_cell(textwrap.dedent("""\
            vals_array = np.reshape(ma.masked_where(vals == np.nan, vals), shape)
            plt.title(r'{} on {} [{}]'.format(variable,current_date,unit))
            plt.pcolormesh(lat,lon,vals_array)
            plt.colorbar()
            plt.xlabel('lat')
            plt.ylabel('lon')
            plt.plot()""")),
        new_markdown_cell(textwrap.dedent("""\
            ## **Compare model with observations**
            
            ### Convert model output
            Convert model time into dates""")),
        new_code_cell(textwrap.dedent("""\
            dstart = cftime.num2date(tstart, tunit).date()
            dend = cftime.num2date(tend, tunit).date()
            dlist = [cftime.num2date(d[0], tunit).date() for d in variable_overtime]""")),
        new_markdown_cell('Convert the (gprcglob) model output into pandas.DataFrame format (required for hydrostat)'),
        new_code_cell(textwrap.dedent("""\
            var_df = pd.DataFrame(variable_overtime, columns=['sim_time', 'simulation'])
            var_df = var_df.drop(columns=['sim_time'])
            var_df.index = dlist
            var_df.index.name = 'date'""")),
        new_markdown_cell(textwrap.dedent("""\
            ### Import GRDC data
            Load the data using GRDC station id and the start and end date of the model run""")),
    ]
    station_id = setup['assessment']['station_id']
    if assessment_source == 'grdc':
        cells += [
            new_code_cell(textwrap.dedent("""\
                station_id = '{0}' 
                observations = get_usgs_data(station_id, str(dstart), str(dend))""").format(station_id)),
        ]
    elif assessment_source == 'usgs':
        cells += [
            new_code_cell(textwrap.dedent("""\
                station_id = '{0}' 
                observations = get_grdc_data(station_id, str(dstart), str(dend))""").format(station_id)),
        ]

    cells += [
        new_markdown_cell('Combine GRDC data with the model output'),
        new_code_cell(textwrap.dedent("""\
            obs_df = observations.to_dataframe()
            var_df["observation"] = obs_df["streamflow"]""")),
        new_markdown_cell(textwrap.dedent("""\
            Plot hydrograph for simulated and observed values and calculate following metrics (using hydrostats):
             - ME: Mean error
             - NSE: Nash-Sutcliffe Efficiency 
             - SA: Spectral Angle
             
            For more information: https://byu-hydroinformatics.github.io/HydroErr/list_of_metrics.html""")),
        new_code_cell(textwrap.dedent("""\
            hv.plot(var_df[['simulation', 'observation']],
            title='Hydrograph of Lobith',
            linestyles=['r-', 'k-'],
            legend=('Simulated', 'Observed'),
            labels=['Datetime', 'Streamflow (cms)'],
            metrics=['ME', 'NSE', 'SA'],
            grid=True)
            plt.show()""")),
        new_markdown_cell('Stop the Docker container'),
        new_code_cell('del model'),
    ]
    return new_notebook(cells=cells, metadata=PY3_META)


def post(body):
    """Generate notebook and launch it

    Args:
        body: The json POST body as a Python object
    """
    nb = assessment_notebook(body['setup'])
    return process_notebook(body['notebook'], nb)
